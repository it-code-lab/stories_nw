import os
import time
from pathlib import Path
from datetime import datetime

from playwright.sync_api import sync_playwright
from openpyxl import load_workbook
import re

# ================== CONFIG ==================

# Pinterest
PINTEREST_BASE_URL = "https://ca.pinterest.com/"
PIN_BUILDER_URL = "https://ca.pinterest.com/pin-builder/"

# Update these paths for your machine
PROFILE_DIR = r"C:\Users\mail2\AppData\Local\Google\Chrome\User Data\Profile 21"
CHROME_EXECUTABLE = r"C:\Program Files\Google\Chrome\Application\chrome.exe"

# Excel generated by your pin script
EXCEL_FILE = "master_shorts_uploader_data.xlsx"

# Media files are usually stored relative to your app root, e.g. "pinterest_pins/filename.webp"
BASE_DIR = Path(__file__).resolve().parent
MEDIA_BASE = BASE_DIR / "pinterest_uploads"   # so media_file paths are relative to the app root

# ================== EXCEL HELPERS ==================


def ensure_status_columns(ws, headers):
    """
    Ensure these columns exist:
    - pinterest_pin_url
    - pinterest_upload_status
    - pinterest_uploaded_at

    Returns updated headers list and a header->column_index map (1-based).
    """
    extra_cols = ["pinterest_pin_url", "pinterest_upload_status", "pinterest_uploaded_at"]
    changed = False

    for col_name in extra_cols:
        if col_name not in headers:
            headers.append(col_name)
            ws.cell(row=1, column=len(headers), value=col_name)
            changed = True

    header_map = {name: idx + 1 for idx, name in enumerate(headers)}
    return headers, header_map, changed


def load_pins_from_excel():
    """
    Load pins from master_shorts_uploader_data.xlsx.
    Ensures status columns exist and returns:

    wb, ws, pins, header_map

    Where pins is a list of dicts, each with:
    - all header fields
    - "_row_idx" key indicating Excel row number
    """
    wb = load_workbook(EXCEL_FILE)
    ws = wb.active

    headers = [cell.value for cell in ws[1]]
    headers = [h if h is not None else "" for h in headers]

    headers, header_map, changed = ensure_status_columns(ws, headers)

    pins = []
    for row_idx, row in enumerate(ws.iter_rows(min_row=2, values_only=True), start=2):
        # Build record mapping header -> cell value (None if beyond row length)
        record = {h: (row[i] if i < len(row) else None) for i, h in enumerate(headers)}
        record["_row_idx"] = row_idx

        media_file = (record.get("media_file") or "").strip()
        pin_title = (record.get("pin_title") or "").strip()
        pinterestProfile = (record.get("pinterestProfile") or "").strip()

        if pinterestProfile == "" :
            continue
        
        if not media_file or not pin_title:
            continue  # skip incomplete rows

        pins.append(record)

    return wb, ws, pins, header_map


def save_pin_status(ws, header_map, row_idx, url, status):
    """
    Save status back into Excel for a specific row.
    """
    now_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    url_col = header_map.get("pinterest_pin_url")
    status_col = header_map.get("pinterest_upload_status")
    ts_col = header_map.get("pinterest_uploaded_at")

    if url_col:
        ws.cell(row=row_idx, column=url_col, value=url)
    if status_col:
        ws.cell(row=row_idx, column=status_col, value=status)
    if ts_col:
        ws.cell(row=row_idx, column=ts_col, value=now_str)


def is_excel_file_locked(file_path):
    try:
        with open(file_path, "a"):
            pass
        return False
    except PermissionError:
        return True


# ================== PINTEREST HELPERS ==================


def resolve_media_path(media_file: str) -> str:
    """
    Resolve media_file path relative to MEDIA_BASE.
    """
    # normalize separators
    rel = media_file.replace("\\", "/")
    full_path = (MEDIA_BASE / rel).resolve()
    return str(full_path)


def open_pin_builder(page):
    page.goto(PIN_BUILDER_URL)
    page.wait_for_load_state("networkidle")
    time.sleep(2)


def upload_media(page, media_path: str):
    """
    Upload image or video into the Pin builder.
    Uses the recorded data-test-id pattern from your Pinterest UI.
    """
    print(f"  -> Uploading media: {media_path}")

    # Use the data-test-id that Pinterest assigns to the upload input.
    # The exact id may change per session, so we use a "starts with" selector.
    file_input = page.locator('[data-test-id^="media-upload-input"]')

    # If there are multiple, choose the first visible one
    count = file_input.count()
    if count == 0:
        # Fallback to plain file input if needed
        print("  [WARN] No [data-test-id^='media-upload-input'] found, trying input[type='file'].")
        file_input = page.locator('input[type="file"]')
        count = file_input.count()

    if count == 0:
        raise RuntimeError("Could not find any media upload input on the page.")

    target = file_input.first
    if count > 1:
        # prefer visible input
        for i in range(count):
            el = file_input.nth(i)
            if el.is_visible():
                target = el
                break

    target.set_input_files(media_path)
    time.sleep(3)



import re

def fill_text_field(page, label_text: str, value: str, fallback_placeholder: str | None = None):
    """
    Fill fields based on the patterns observed in your Pinterest UI.

    label_text is a semantic hint ("Title", "Description", "Destination link").
    We map these to the recorded locators first, then fall back if needed.
    """
    value = value or ""
    if not value:
        return

    # ---- Title ----
    if label_text.lower() == "title":
        try:
            box = page.get_by_role("textbox", name="Add your title")
            box.click()
            box.fill(value)
            return
        except Exception as e:
            print(f"  [WARN] Title field via 'Add your title' failed: {e}")

    # ---- Description ----
    if label_text.lower() == "description":
        # The recording showed: getByRole('combobox', { name: 'Tell everyone what your Pin' })
        try:
            desc = page.get_by_role("combobox", name=re.compile(r"Tell everyone what your Pin", re.I))
            desc.click()
            try:
                # In many UIs, combobox acts like a textarea and supports fill()
                desc.fill(value)
            except Exception:
                # If fill() is not supported, type text as fallback
                desc.type(value, delay=5)
            return
        except Exception as e:
            print(f"  [WARN] Description field via 'Tell everyone what your Pin' failed: {e}")

    # ---- Destination link ----
    if label_text.lower() in ["destination link", "link"]:
        try:
            link_box = page.get_by_role("textbox", name="Add a destination link")
            link_box.click()
            link_box.fill(value)
            return
        except Exception as e:
            print(f"  [WARN] Destination link field via 'Add a destination link' failed: {e}")

    # ---- Fallbacks (generic) ----
    # Try label-based match (if any real <label> exists)
    try:
        field = page.get_by_label(label_text)
        field.fill(value)
        return
    except Exception:
        pass

    # Try placeholder
    if fallback_placeholder:
        try:
            field = page.get_by_placeholder(fallback_placeholder)
            field.fill(value)
            return
        except Exception:
            pass

    print(f"  [WARN] Could not find field for label '{label_text}'. Please adjust selectors if needed.")



def select_board(page, board_name: str):
    """
    Open the board dropdown and select the board matching board_name.
    Uses the data-test-id + 'BoardName Publish' pattern you recorded.
    """
    board_name = (board_name or "").strip()
    if not board_name:
        print("  [INFO] No board_name provided; skipping board selection.")
        return

    print(f"  -> Selecting board: {board_name!r}")

    # Click the board dropdown
    try:
        page.locator('[data-test-id="board-dropdown-select-button"]').click()
        time.sleep(1)
    except Exception as e:
        print(f"  [WARN] Could not click board dropdown: {e}")
        return

    # The button for the board appears as e.g. 'Kids Coloring Pages Publish'
    try:
        btn_text = f"{board_name} Publish"
        page.get_by_role("button", name=btn_text).click()
        time.sleep(1)
    except Exception as e:
        print(f"  [WARN] Could not click board button '{board_name} Publish': {e}")



def click_save(page):
    """
    Click the Save button to publish the pin.
    """
    print("  -> Clicking Save...")
    try:
        # Main save button for the pin
        # save_btn = page.get_by_role("button", name="Save")
        # save_btn.click()
        page.locator('[data-test-id="board-dropdown-save-button"]').click()
    except Exception:
        # Fallback if name slightly differs
        try:
            page.get_by_text("Publish").click()
        except Exception as e:
            print(f"  [ERROR] Could not click Save button: {e}")
            raise

    time.sleep(5)


def extract_pin_url(page) -> str:
    """
    After saving, Pinterest usually navigates to the pin URL:
    something like https://www.pinterest.com/pin/1234567890/
    """
    url = page.url
    if "/pin/" in url:
        return url

    # Some flows show a dialog; try to locate a link with 'pin/' in href
    try:
        link = page.locator('a[href*="/pin/"]').first
        if link:
            href = link.get_attribute("href")
            if href:
                if href.startswith("http"):
                    return href
                else:
                    return PINTEREST_BASE_URL.rstrip("/") + href
    except Exception:
        pass

    return "Unknown"

def fill_description(page, pin_desc: str):
    """
    Fill the Pinterest description (Tell everyone what your Pin is about) field.

    We:
    - locate the contenteditable div via aria-label
    - focus it via JS (no click, so no 'enabled' check)
    - clear existing text with keyboard
    - type the new description
    """
    import re

    pin_desc = (pin_desc or "").strip()
    if not pin_desc:
        return

    try:
        # 1. Locate the contenteditable div by aria-label
        desc = page.locator(
            'div[contenteditable="true"][role="combobox"][aria-label*="Tell everyone what your Pin"]'
        )

        # Fallback with regex on aria-label, just in case Pinterest tweaks the text slightly
        if desc.count() == 0:
            desc = page.locator(
                'div[contenteditable="true"][role="combobox"]'
            ).filter(
                has_text=re.compile(r".*")
            )

        if desc.count() == 0:
            raise RuntimeError("Description contenteditable combobox not found")

        el = desc.first

        # 2. Ensure it's visible in DOM
        el.wait_for(state="visible", timeout=15000)

        # 3. Focus via JS (bypass 'enabled' checks used by click())
        el.evaluate("el => el.focus()")

        # Small pause to let focus settle
        page.wait_for_timeout(300)

        # 4. Clear existing text using keyboard
        try:
            page.keyboard.press("Control+A")
            page.keyboard.press("Backspace")
        except Exception:
            # if Control doesn't work (Mac), Meta may be needed, but usually Control is fine on Windows
            pass

        page.wait_for_timeout(100)

        # 5. Type the description
        page.keyboard.type(pin_desc, delay=5)

        print("  -> Description filled.")

    except Exception as e:
        print(f"[WARN] Could not fill description: {e}")


def create_pin(page, pin_info: dict) -> str:
    """
    Core flow: open pin builder, upload media, set fields, select board, save.
    Returns pin URL (or 'Unknown').
    """
    print(f"\n=== Creating Pin for media: {pin_info.get('media_file')} ===")

    open_pin_builder(page)

    media_path = resolve_media_path(str(pin_info["media_file"]))
    if not os.path.exists(media_path):
        raise FileNotFoundError(f"Media file not found: {media_path}")

    upload_media(page, media_path)

    # Title
    pin_title = (pin_info.get("pin_title") or "").strip()

    # Limit length to 100 characters
    if len(pin_title) > 100:
        pin_title = pin_title[:100]
        print("  [INFO] Title truncated to 100 characters.")

    fill_text_field(
        page,
        label_text="Title",
        value=pin_title,
        fallback_placeholder="Add your title",
    )
    print("  -> Title filled.")

    # Description
    pin_desc = (pin_info.get("pin_description") or "").strip()
    fill_description(page, pin_desc)
    print("  -> Description filled.")

    # Destination link
    pin_link = (pin_info.get("pin_url_to_link") or pin_info.get("book_url") or "").strip()
    if pin_link:
        fill_text_field(
            page,
            label_text="Destination link",
            value=pin_link,
            fallback_placeholder="Add a destination link",
        )
        print(f"  -> Destination link filled: {pin_link}")
    else:
        print("  [INFO] No destination link provided; leaving link blank.")

    # Board selection
    board_name = pin_info.get("board_name") or ""
    select_board(page, board_name)

    # Save
    click_save(page)

    # Extract Pin URL
    pin_url = extract_pin_url(page)
    print(f"  -> Pin created: {pin_url}")
    return pin_url


# ================== MAIN UPLOADER ==================


def upload_pins():
    if not os.path.exists(EXCEL_FILE):
        print(f"Error: Excel file not found: {EXCEL_FILE}")
        return

    if is_excel_file_locked(EXCEL_FILE):
        print(f"Error: Please close '{EXCEL_FILE}' before running the uploader.")
        return

    wb, ws, pins, header_map = load_pins_from_excel()

    if not pins:
        print("No valid pins found in Excel for Pinterest upload")
        return

    print(f"Loaded {len(pins)} pin rows from {EXCEL_FILE}")

    with sync_playwright() as p:
        browser = p.chromium.launch_persistent_context(
            PROFILE_DIR,
            headless=False,
            executable_path=CHROME_EXECUTABLE,
            args=["--disable-blink-features=AutomationControlled", "--start-maximized"],
        )
        page = browser.new_page()

        # Hide automation fingerprint
        page.add_init_script(
            "Object.defineProperty(navigator, 'webdriver', {get: () => undefined})"
        )

        # You should already be logged in to Pinterest in this Chrome profile.
        # If not, the first run will open the login page; log in manually and then rerun.

        # Go from bottom to top (similar to your YouTube uploader)
        # total = len(pins)
        # for rev_idx, pin in enumerate(reversed(pins), start=1):
        #     row_idx = total - rev_idx + 2  # Excel row index (header is row 1)
        for pin in reversed(pins):
            row_idx = pin["_row_idx"]  # <--- Use the stored absolute row index
            status_val = str(pin.get("pinterest_upload_status") or "").strip().lower()
            future_val = str(pin.get("future") or "").strip().lower()
            if status_val == "success":
                print(f"Skipping already uploaded: {pin.get('pin_title')}")
                continue

            if future_val == "future":
                print(f"Skipping row for future: {pin.get('pin_title')}")
                continue

            if pin.get("pinterestProfile", "") == "":
                print(f"Skipping row {row_idx} due to missing pinterestProfile.")
                continue

            try:
                pin_url = create_pin(page, pin)
                save_pin_status(ws, header_map, row_idx, pin_url, "Success")
                print(f"✅ Pin created & recorded for row {row_idx}")
                wb.save(EXCEL_FILE)
            except Exception as e:
                err_msg = str(e)[:500]
                print(f"❌ Error creating pin for row {row_idx}: {err_msg}")
                save_pin_status(ws, header_map, row_idx, "", err_msg)
                wb.save(EXCEL_FILE)

            # Small pause between pins to be gentle
            time.sleep(3)

        wb.save(EXCEL_FILE)
        browser.close()

    print("All done.")


if __name__ == "__main__":
    upload_pins()
